Lambda Expressions
Lambda expression provides implementation of functional interface. An interface which has only one abstract method is called functional interface. 
Java provides an anotation @FunctionalInterface, which is used to declare an interface as functional interface.
In case of lambda expression, we don't need to define the method again for providing the implementation. Here, we just write the implementation code.
@FunctionalInterface  //It is optional  
interface Drawable{  
    public void draw();  
}  
  
public class LambdaExpressionExample2 {  
    public static void main(String[] args) {  
        int width=10;  
        
        //with lambda  
        Drawable d2=()->{  
            System.out.println("Drawing "+width);  
        };  
        d2.draw();  
    }  
}  
**********************
List<Integer>al=Array.asList(1,2,3,4,5)
al.stream().filter(n->n%2==0).forEach(System.out::println)
**********************************************
There are following types of method references in java:

Reference to a static method.
Reference to an instance method.
Reference to a constructor.
***************************************
interface Sayable{  
    void say();  
}  
public class MethodReference {  
    public static void saySomething(){  
        System.out.println("Hello, this is static method.");  
    }  
    public static void main(String[] args) {  
        // Referring static method  
        Sayable sayable = MethodReference::saySomething;  
        // Calling interface method  
        sayable.say();  
    }  
}  
*******************
 Reference to an Instance Method
interface Sayable{  
    void say();  
}  
public class InstanceMethodReference {  
    public void saySomething(){  
        System.out.println("Hello, this is non-static method.");  
    }  
    public static void main(String[] args) {  
        InstanceMethodReference methodReference = new InstanceMethodReference(); // Creating object  
        // Referring non-static method using reference  
            Sayable sayable = methodReference::saySomething;  
        // Calling interface method  
            sayable.say();  
            // Referring non-static method using anonymous object  
            Sayable sayable2 = new InstanceMethodReference()::saySomething; // You can use anonymous object also  
            // Calling interface method  
            sayable2.say();  
    }  
}  
***********************************************
Functional Interface is also known as Single Abstract Method Interfaces or SAM Interfaces. 
It is a new feature in Java, which helps to achieve functional programming approach.
Java Predefined-Functional Interfaces----->
Function<T,R>--->It represents a function that accepts one argument and returns a result.
BiFunction<T,U,R>	It represents a function that accepts two arguments and returns a a result.
*************************************
List<Integer>al=Array.asList(1,2,3,4)
int a=al.stream().count()
al.ForEach(b->System.out.println(b));
bollean b=al.stream().anyMatch(n->n%2==0);
List<Integer>distinctNumber=al.stream().distinct().collect(Collectors.toList())
List<Integer>evenSquare=al.stream().filter(n->n%2==0).map(n->n*n).collect(Collectors.toList());
*********************************************************************************************************
optional class was introduced to avoid NullPointerExceptions to handle nullable values.
optional represnt the state of empty as well as filled.

import java.util.Optional;

public class OptionalExample {
    public static void main(String[] args) {
        String[] str = new String[5];
        str[2] = "Geeks Classes are coming soon";

        // Create an Optional with a non-null value
        Optional<String> value = Optional.of(str[2]);

        // Retrieve the value
        System.out.println("Value: " + value.get());

        // Check if a value is present
        System.out.println("Is present? " + value.isPresent());

        // Hash code of the Optional
        System.out.println("Hash code: " + value.hashCode());
    }
}

**************************************
import java.util.Optional;

public class Example {
    public static void main(String[] args) {
        String[] names = new String[5];
        Optional<String> optionalName = Optional.ofNullable(names[3]);

        if (optionalName.isPresent()) {
            String upperCaseName = optionalName.get().toUpperCase();
            System.out.println("Name: " + upperCaseName);
        } else {
            System.out.println("Name is not present.");
        }
    }
}
***********************************************************
obtain an empty Optional instance using its static method empty()
 Optional<String> emptyOptional = Optional.empty();
*********
equals() method is used to compare two Optional instances. 
Optional<String> opt1 = Optional.of("Hello");
        Optional<String> opt2 = Optional.of("Hello");
        
        if (opt1.equals(opt2)) {
            System.out.println("Opt1 and Opt2 are equal.");
        } else {
            System.out.println("Opt1 and Opt2 are not equal.");
        }
 
**************************************************
ifPresent() - It takes a Consumer functional interface as an argument, 
which represents the action to be performed on the value if it is present.
Optional<String> optionalString = Optional.of("Hello");
        
        optionalString.ifPresent(s -> System.out.println("Value is present: " + s));
        
        Optional<String> emptyOptional = Optional.empty();
        
        emptyOptional.ifPresent(s -> System.out.println("This will not be printed as the Optional is empty."));
******************************
of()-->Creating an Optional with a non-null value
Optional<String> nullOptional = Optional.of(null);--->will throw a NullPointerException
*****************************************
orElse() method is used in the Optional class to provide a default value if the Optional instance is empty
Optional<String> optionalString = Optional.of("Hello");
        
        // Retrieving the value from optionalString, or "Default" if optionalString is empty
        String value = optionalString.orElse("Default");
        System.out.println("Value: " + value); // Output: Value: Hello
        
        Optional<String> emptyOptional = Optional.empty();
        
        // Retrieving the value from emptyOptional, or "Default" if emptyOptional is empty
        String value2 = emptyOptional.orElse("Default");
        System.out.println("Value2: " + value2); // Output: Value2: Default
******************************
orElseGet()  
 it takes a Supplier functional interface as an argument instead of a direct value.
Optional<String> optionalString = Optional.of("Hello");
        
        // Using orElseGet with a supplier that generates the default value
        String value = optionalString.orElseGet(() -> generateDefaultValue());
        System.out.println("Value: " + value); // Output: Value: Hello
        
        Optional<String> emptyOptional = Optional.empty();
        
        // Using orElseGet with a supplier that generates the default value
        String value2 = emptyOptional.orElseGet(() -> generateDefaultValue());
        System.out.println("Value2: " + value2); // Output: Value2: Default Value
 public static String generateDefaultValue() {
        System.out.println("Generating default value...");
        return "Default Value";
    }
********************
orElseThrow() method in the Optional class is used to retrieve the value contained in the Optional if it is present. 
If the Optional is empty, it throws an exception specified by a provided supplier.
Optional<String> optionalString = Optional.of("Hello");
        
        // Retrieving the value from optionalString, or throwing an exception if optionalString is empty
        String value = optionalString.orElseThrow(() -> new IllegalStateException("Value is not present"));
        System.out.println("Value: " + value); // Output: Value: Hello
        
        Optional<String> emptyOptional = Optional.empty();
        
        try {
            // Attempting to retrieve the value from emptyOptional, which will throw an exception
            String value2 = emptyOptional.orElseThrow(() -> new IllegalStateException("Value is not present"));
            System.out.println("Value2: " + value2);
        } catch (IllegalStateException e) {
            System.out.println("Exception caught: " + e.getMessage()); // Output: Exception caught: Value is not present
        }
*********************************************
String str=null
Optional<String> o=Optional.ofNullable(str);
System.out.println( o.get())------->Optional.ofNullable() and the value is null, it will throw a NoSuchElementException.
*******************




