
2043) simple-bank-system
  ****
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Bank {

    private static final class Account {
        private Long balance;
        private final Lock lock = new ReentrantLock(true);

        public Account(Long balance) {
            this.balance = balance;
        }

        public boolean deposit(long amount) {
            lock.lock();
            try {
                balance += amount;
            } finally {
                lock.unlock();
            }

            return true;
        }

        public boolean withdraw(long amount) {
            lock.lock();
            try {
                if (balance < amount) return false;
                balance -= amount;
            } finally {
                lock.unlock();
            }

            return true;
        }
    }

    private final Map<Integer, Account> accounts = new ConcurrentHashMap<>();

    public Bank(long[] balance) {

        for (int i = 0; i < balance.length; i++) {
            accounts.put(i, new Account(balance[i]));
        }
    }

    public boolean transfer(int account1, int account2, long money) {
        if (!validateAccount(account1) || !(validateAccount(account2)) || money < 0) return false;

        var acc1 = getAccount(account1);
        var acc2 = getAccount(account2);

        acc1.lock.lock();
        try {
            acc2.lock.lock();
            try {
                if (acc1.withdraw(money)) {
                    acc2.deposit(money);
                } else {
                    return false;
                }
            } finally {
                acc2.lock.unlock();
            }
        } finally {
            acc1.lock.unlock();
        }

        return true;
    }

    public boolean deposit(int account, long money) {
        if (!validateAccount(account)) return false;
        return getAccount(account).deposit(money);
    }


    public boolean withdraw(int account, long money) {
        if (!validateAccount(account)) return false;
        return getAccount(account).withdraw(money);
    }

    private boolean validateAccount(int account) {
        return account >= 0 && account <= accounts.size();
    }

    private Account getAccount(int account) {
        var acc = accounts.get(account - 1);
        if (acc == null)
            throw new IllegalStateException("invalid account definition " + account + " " + accounts.size());

        return acc;
    }
}
***************************************************************************
2241 Design ATM machine

class ATM {
    private int[] banknotesStore;
    private int[] noteTypes;
    public ATM() {
        banknotesStore=new int[5];
        noteTypes=new int[5];
        noteTypes[0]=20;
        noteTypes[1]=50;
        noteTypes[2]=100;
        noteTypes[3]=200;
        noteTypes[4]=500;




    }
    
    public void deposit(int[] banknotesCount) {
        for(int i=0;i<5;i++){
            banknotesStore[i]+=banknotesCount[i];
        }
    }
    
    public int[] withdraw(int amount) {
        int[] ans=new int[5];
        for(int i=4;i>=0;i--){
           if(amount>=noteTypes[i]){
                int c=amount/noteTypes[i];
                if(c>banknotesStore[i]){
                    c=banknotesStore[i];
                }
                banknotesStore[i]=banknotesStore[i]-c;
                amount=amount-(c*noteTypes[i]);
                ans[i]+=c;

           }
         
        }
        if(amount==0){
            return ans;
        }
        else{
            for(int i=0;i<=4;i++){
                banknotesStore[i]+=ans[i];
               
            }

            return new int[]{-1};
        }
    }
}

/**
 * Your ATM object will be instantiated and called as such:
 * ATM obj = new ATM();
 * obj.deposit(banknotesCount);
 * int[] param_2 = obj.withdraw(amount);
 */
***************************************************************************************************************************************************
535) encode-and-decode-tinyurl

public class Codec {

      Map<String,String> longUrlKey=new HashMap<>();
      Map<String,String> shortUrlKey=new HashMap<>();
          static final String chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    public String getCode(){
         char[] ch=new char[6];
        for(int i=0;i<6;i++){
            ch[i]=chars.charAt((int)(Math.random()*62));
        }
        return  "http://tinyurl.com/"+String.valueOf(ch);
    }
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
       if(longUrlKey.containsKey(longUrl)){
          return longUrlKey.get(longUrl);
       }
       String code=getCode();
       while(shortUrlKey.containsKey(code)){
         code=getCode();
       }
        longUrlKey.put(longUrl,code);
        shortUrlKey.put(code,longUrl);
         return code;
    }

    public String decode(String shortUrl) {
        return shortUrlKey.get(shortUrl);
    }
}
****************************************************************
1845
seat-reservation-manager
class SeatManager {
    private PriorityQueue<Integer> seats; 
    public SeatManager(int n) {
        seats=new PriorityQueue<>();
        for(int i=1;i<=n;i++){
           seats.offer(i);
        }
    }
    
    public int reserve() {
       
            if(!seats.isEmpty()){
                int a=seats.poll();
                
                return a;
            }
        
        return -1;
    }
    
    public void unreserve(int seatNumber) {
        seats.offer(seatNumber);
    }
}
****************************************************************************
1472
Design BrowserHistory

class BrowserHistory {
   private List<String> al;
   private int cursor=0;
    public BrowserHistory(String homepage) {
        al=new ArrayList<>();
       al.add(homepage);
    }
    
    public void visit(String url) {
        while(al.size()>cursor+1){
            al.remove(al.size()-1);
        }
        al.add(url);
        cursor+=1;
    }
    
    public String back(int steps) {
        if(cursor-steps<0){
            cursor=0;
            return al.get(cursor);

        }
        else{
            cursor=cursor-steps;
            return al.get(cursor);
        }
    }
    
    public String forward(int steps) {
        if(cursor+steps>=al.size()){
           cursor=al.size()-1;
           return al.get(cursor);
        }
        cursor=cursor+steps;
        return al.get(cursor);

    }
}
*******************************************************************************************************
933
Number of Recent calls

You have a RecentCounter class which counts the number of recent requests within a certain time frame.
Implement the RecentCounter class:
RecentCounter() Initializes the counter with zero recent requests.
int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].


class RecentCounter {
    Queue<Integer> q;
    public RecentCounter() {
        q=new LinkedList<Integer>();

    }
    
    public int ping(int t) {
        q.add(t);
        while(q.peek()<t-3000){
            q.remove();
        }
        return q.size();
    }
}
***************************************************************************
225
Implement-stack-using-queues
*********
class MyStack {

   private Queue<Integer> queue;
    public MyStack() {
        queue=new LinkedList<>();
        
    }
    
    public void push(int x) {
        queue.add(x);
        int size=queue.size();
        while(size>1){
            size--;
            queue.add(queue.remove());
        }
    
    }
    
    public int pop() {
        
        return queue.remove();
    }
    
    public int top() {
      
        return queue.peek();
    }
    
    public boolean empty() {
        return queue.isEmpty();
    }
}
******************************************************
622
Design Circular queue
*****
class MyCircularQueue {
    private int[] arr;
     private int front;
     private int rear;
     private int size;
     private int capacity;
    public MyCircularQueue(int k) {
        arr=new int[k];
        this.front=0;
        this.rear=-1;
        this.size=0;
        this.capacity=k;

    }
    
    public boolean enQueue(int value) {
        if(size==capacity){
            return false;
        }
        rear=(rear+1)%capacity;
        arr[rear]=value;
        size++;
        return true;
    }
    
    public boolean deQueue() {
        if(size==0){
            return false;
        }
        front=(front+1)%capacity;
        size--;
        return true;
    }
    
    public int Front() {
        if(size==0){
            return -1;
        }
        return arr[front];
    }
    
    public int Rear() {
        if(size==0){
            return -1;
        }
        return arr[rear];
    }
    
    public boolean isEmpty() {
        return size==0;
    }
    
    public boolean isFull() {
        return size==capacity;
    }
}
*************************************************************************************************************************************************


