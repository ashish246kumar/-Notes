
2043) simple-bank-system
  ****
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class Bank {

    private static final class Account {
        private Long balance;
        private final Lock lock = new ReentrantLock(true);

        public Account(Long balance) {
            this.balance = balance;
        }

        public boolean deposit(long amount) {
            lock.lock();
            try {
                balance += amount;
            } finally {
                lock.unlock();
            }

            return true;
        }

        public boolean withdraw(long amount) {
            lock.lock();
            try {
                if (balance < amount) return false;
                balance -= amount;
            } finally {
                lock.unlock();
            }

            return true;
        }
    }

    private final Map<Integer, Account> accounts = new ConcurrentHashMap<>();

    public Bank(long[] balance) {

        for (int i = 0; i < balance.length; i++) {
            accounts.put(i, new Account(balance[i]));
        }
    }

    public boolean transfer(int account1, int account2, long money) {
        if (!validateAccount(account1) || !(validateAccount(account2)) || money < 0) return false;

        var acc1 = getAccount(account1);
        var acc2 = getAccount(account2);

        acc1.lock.lock();
        try {
            acc2.lock.lock();
            try {
                if (acc1.withdraw(money)) {
                    acc2.deposit(money);
                } else {
                    return false;
                }
            } finally {
                acc2.lock.unlock();
            }
        } finally {
            acc1.lock.unlock();
        }

        return true;
    }

    public boolean deposit(int account, long money) {
        if (!validateAccount(account)) return false;
        return getAccount(account).deposit(money);
    }


    public boolean withdraw(int account, long money) {
        if (!validateAccount(account)) return false;
        return getAccount(account).withdraw(money);
    }

    private boolean validateAccount(int account) {
        return account >= 0 && account <= accounts.size();
    }

    private Account getAccount(int account) {
        var acc = accounts.get(account - 1);
        if (acc == null)
            throw new IllegalStateException("invalid account definition " + account + " " + accounts.size());

        return acc;
    }
}
***************************************************************************
2241 Design ATM machine

class ATM {
    private int[] banknotesStore;
    private int[] noteTypes;
    public ATM() {
        banknotesStore=new int[5];
        noteTypes=new int[5];
        noteTypes[0]=20;
        noteTypes[1]=50;
        noteTypes[2]=100;
        noteTypes[3]=200;
        noteTypes[4]=500;




    }
    
    public void deposit(int[] banknotesCount) {
        for(int i=0;i<5;i++){
            banknotesStore[i]+=banknotesCount[i];
        }
    }
    
    public int[] withdraw(int amount) {
        int[] ans=new int[5];
        for(int i=4;i>=0;i--){
           if(amount>=noteTypes[i]){
                int c=amount/noteTypes[i];
                if(c>banknotesStore[i]){
                    c=banknotesStore[i];
                }
                banknotesStore[i]=banknotesStore[i]-c;
                amount=amount-(c*noteTypes[i]);
                ans[i]+=c;

           }
         
        }
        if(amount==0){
            return ans;
        }
        else{
            for(int i=0;i<=4;i++){
                banknotesStore[i]+=ans[i];
               
            }

            return new int[]{-1};
        }
    }
}

/**
 * Your ATM object will be instantiated and called as such:
 * ATM obj = new ATM();
 * obj.deposit(banknotesCount);
 * int[] param_2 = obj.withdraw(amount);
 */
***************************************************************************************************************************************************
535) encode-and-decode-tinyurl

public class Codec {

      Map<String,String> longUrlKey=new HashMap<>();
      Map<String,String> shortUrlKey=new HashMap<>();
          static final String chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    public String getCode(){
         char[] ch=new char[6];
        for(int i=0;i<6;i++){
            ch[i]=chars.charAt((int)(Math.random()*62));
        }
        return  "http://tinyurl.com/"+String.valueOf(ch);
    }
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
       if(longUrlKey.containsKey(longUrl)){
          return longUrlKey.get(longUrl);
       }
       String code=getCode();
       while(shortUrlKey.containsKey(code)){
         code=getCode();
       }
        longUrlKey.put(longUrl,code);
        shortUrlKey.put(code,longUrl);
         return code;
    }

    public String decode(String shortUrl) {
        return shortUrlKey.get(shortUrl);
    }
}
****************************************************************
1845
seat-reservation-manager
class SeatManager {
    private PriorityQueue<Integer> seats; 
    public SeatManager(int n) {
        seats=new PriorityQueue<>();
        for(int i=1;i<=n;i++){
           seats.offer(i);
        }
    }
    
    public int reserve() {
       
            if(!seats.isEmpty()){
                int a=seats.poll();
                
                return a;
            }
        
        return -1;
    }
    
    public void unreserve(int seatNumber) {
        seats.offer(seatNumber);
    }
}
****************************************************************************




