701. Insert into a Binary Search Tree

class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null){
            return new TreeNode(val);
        }
        TreeNode root1=root;
        while(true){
            if(root1.val<=val){
                if(root1.right!=null){
                    root1=root1.right;

                }
                else{
                    root1.right=new TreeNode(val);
                    break;
                }
            }
            else{
                if(root1.left!=null){
                    root1=root1.left;
                }
                else{
                    root1.left=new TreeNode(val);
                    break;
                }

            }
        }
        return root;
    }
}
*************************************************************************************************************************************
Delete a Node in bst
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null){
            return root;
        }
        if(root.val==key){
           return helper(root);
        }
        TreeNode root1=root;
        while(root!=null){
            if(root.val>=key){
                if(root.left!=null && root.left.val==key){
                    root.left=helper(root.left);
                    break;
                }
                else{
                 root=root.left;
                }
            }
            else{
                if(root.right!=null && root.right.val==key){
                    root.right=helper(root.right);
                    break;
                }
                else{
                 root=root.right;
                }
            }
        }
        return root1;

    }
    TreeNode helper(TreeNode root){
        if(root.left==null){
            return root.right;
        }
        else if(root.right==null){
            return root.left;    
        }
        TreeNode rightChild=root.right;
        TreeNode lastright=findLastRight(root.left);
        lastright.right=rightChild;
        return root.left;
    }
    TreeNode findLastRight(TreeNode root){
           
            if(root.right==null){
               return root;
            }
            
          return findLastRight(root.right);
    }
}
**************************************************************************
ceil in a bst
************
class Tree {
    // Function to return the ceil of given number in BST.
    int findCeil(Node root, int key) {
        // if (root == null) return -1;
        // Code here
        int ceil=-1;
        while(root!=null){
            if(root.data==key){
                return root.data;
            }
            else if(root.data<key){
              root=root.right;  
            }
            else{
               ceil=root.data; 
               root=root.left; 
            }
        }
        return ceil;
    }
}
****************************************************************************
Floor in BST
*****
class Solution {
    public static int floor(Node root, int x) {
        // Code here
        int floor=-1;
        while(root!=null){
            if(root.data==x){
                return root.data;
            }
            if(root.data<x){
                floor=root.data;
               root=root.right;
               
            }
            else{
              root=root.left;  
            }
            
            
        }
        return floor;
    }
}
*****************************************************************************************************************************************
Kth smallest element in bst
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int[] arr=new int[1];
        int[]counter=new int[1];
        traverse(root,k,counter,arr);
        return arr[0];

    }
    private void traverse(TreeNode root, int k, int[] counter,int[] arr){
         if(root==null){
            return;
         }
         traverse(root.left,k,counter,arr);
         counter[0]++;
         System.out.println(counter);
         if(counter[0]==k){
            arr[0]=root.val;
            return;
         }
        traverse(root.right,k,counter,arr);

    }
}
***************************************
kth largest Kth largest element in BST

class Solution {
    // return the Kth largest element in the given BST rooted at 'root'
    public int kthLargest(Node root, int k) {
        // Your code here
        int[] counter=new int[1];
        int[] ans=new int[1];
        reverseInorder(root,k,counter,ans);
        return ans[0];
         
    }
        public void reverseInorder(Node root,int k,int[] counter,int[]ans){
               if(root==null){
               return; 
            }

        reverseInorder(root.right,k,counter,ans);
        counter[0]++;
        if(counter[0]==k){
            ans[0]=root.data;
            return;
        }
         reverseInorder(root.left,k,counter,ans);
        }

}

*************************************************
validae binary search tree
**************************************
class Solution {
    public boolean isValidBST(TreeNode root) {
       
        int max=Integer.MAX_VALUE;
        int min=Integer.MIN_VALUE;
       return isValidBinaryST(root,min,max);
    }
    public boolean isValidBinaryST(TreeNode root,int min,int max){
         if(root==null){
            return true;
        }
        if(root.val>=max|| root.val<=min){
            return false;
        }
        
        return isValidBinaryST(root.left,min,root.val)&& isValidBinaryST(root.right,root.val,max);
 
}
******************************
